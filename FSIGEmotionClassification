
import pandas as pd
from nltk.corpus import stopwords
from nltk.stem.wordnet import WordNetLemmatizer
import string
from textblob.classifiers import NaiveBayesClassifier
from textblob import TextBlob
from nltk.corpus import stopwords
from nltk.stem import PorterStemmer
from textblob import Word
from nltk.util import ngrams
import re
from nltk.tokenize import word_tokenize
import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import CountVectorizer,TfidfVectorizer
from sklearn.decomposition import LatentDirichletAllocation
import sklearn.feature_extraction.text as text
from sklearn.decomposition import NMF, LatentDirichletAllocation, TruncatedSVD
from sklearn import model_selection, preprocessing, linear_model, naive_bayes, metrics, svm
import xgboost
from sklearn import decomposition, ensemble
import pandas, numpy, textblob, string
import re
import nltk
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score
from sklearn.metrics import mean_absolute_error
import seaborn as sns
import matplotlib.pyplot as plt
plt.style.use('Solarize_Light2')
nltk.download('stopwords')
#data = pd.read_csv("train-sent.csv")
data = pd.read_csv("trainfinal02.csv")
data
data["love-ATA"].value_counts()
copy = data.copy()
data.head()
data[["text"]]
#convert uppercase letters to lower case
data['text'] = data['text'].apply(lambda x: " ".join(x.lower() for x in x.split()))
#remove white spaces and special characters
data['text'] = data['text'].str.replace('[^\w\s]','')
data[["text"]].head()

stop = stopwords.words("english")
data["text"] = data["text"].apply(lambda x: " ".join(x for x in x.split() if x not in stop))
data[["text"]].head()

# data["content"] = data["content"].apply(lambda x: str(TextBlob(x).correct()))
data[["text"]].head()


st = PorterStemmer()
data["text"] = data["text"].apply(lambda x: " ".join([st.stem(word) for word in x.split()]))
data[["text"]].head()
data["love-ATA"].value_counts()

le = preprocessing.LabelEncoder()
data["love-ATA"] = le.fit_transform(data["love-ATA"])
mapper = {i:le.classes_[i] for i in range(len(le.classes_))}
mapper
data["love-ATA"].value_counts()

X_train, X_test, y_train, y_test = model_selection.train_test_split(data["text"], data["love-ATA"], test_size=0.2, random_state=42, stratify=data["love-ATA"])



cv = CountVectorizer()
cv.fit(data["text"])

cv_xtrain = cv.transform(X_train)
cv_xtest = cv.transform(X_test)


tv = TfidfVectorizer()
tv.fit(data["text"])

tv_xtrain = tv.transform(X_train)
tv_xtest = tv.transform(X_test)


def build(model_initializer, independant_variables_train,target ,independant_variables_test, target_test) :
    model = model_initializer
    model.fit(independant_variables_train,target)
    prediction = model.predict(independant_variables_test)
    return metrics.accuracy_score(prediction, target_test)



# for CV
output = build(linear_model.LogisticRegression(), cv_xtrain, y_train, cv_xtest, y_test)
linear_classifier_count_acc= output
print(output)
# for TF-IDF
output = build(linear_model.LogisticRegression(), tv_xtrain, y_train, tv_xtest , y_test)
linear_classifier_tfidf_acc = output
print(output)


#LRG above
classifier = linear_model.LogisticRegression().fit(tv_xtrain, y_train)
val_predictions = classifier.predict(tv_xtest)

# Precision , Recall , F1 - score , Support
y_true, y_pred = y_test, val_predictions
print(classification_report(y_true, y_pred))



conf_mat = confusion_matrix(y_true, y_pred)
fig, ax = plt.subplots(figsize=(10,10))
sns.heatmap(conf_mat, annot=True, fmt='d',
            xticklabels=le.classes_, yticklabels=le.classes_)
plt.ylabel('Actual')
plt.xlabel('Predicted')
plt.show()


import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix")
plt.show()


#you can use diff classifier but we have chosend LR
#for cv
output = build(svm.SVC(), cv_xtrain, y_train, cv_xtest, y_test)
svm_count_acc = output
print(output)

#for TF-IDF
output = build(svm.SVC(), tv_xtrain, y_train, tv_xtest, y_test)
svm_tfidf_acc = output
print(output)


#for CV
output = build(ensemble.RandomForestClassifier(), cv_xtrain, y_train, cv_xtest, y_test)
print(output)
random_forest_count_acc = output
#for TF-IDF
output = build(ensemble.RandomForestClassifier(), tv_xtrain, y_train, tv_xtest, y_test)
random_forest_tfidf_acc = output
print(output)


# for CV
output = build(naive_bayes.MultinomialNB(), cv_xtrain, y_train  , cv_xtest, y_test)
naive_bayes_count_acc = output
print(output)
# for TF-IDF
output = build(naive_bayes.MultinomialNB(), tv_xtrain, y_train, tv_xtest, y_test)
naive_bayes_tfidf_acc = output
print(output)


dictionary = {
    'algorithm': ['Naive Bayes', 'Naive Bayes', 'Linear Classifier', 'Linear Classifier', 'SVM', 'SVM', 'Random Forest', 'Random Forest'],
    'feature_engineering': ['Count Vector', 'TF-IDF Vector', 'Count Vector', 'TF-IDF Vector', 'Count Vector', 'TF-IDF Vector', 'Count Vector', 'TF-IDF Vector'],
    'accuracy': [naive_bayes_count_acc, naive_bayes_tfidf_acc, linear_classifier_count_acc, linear_classifier_tfidf_acc, svm_count_acc, svm_tfidf_acc, random_forest_count_acc, random_forest_tfidf_acc]
}

# Create a DataFrame
df = pd.DataFrame(dictionary)



classifier = svm.SVC().fit(tv_xtrain, y_train)
val_predictions = classifier.predict(tv_xtest)

# Precision , Recall , F1 - score , Support
y_true, y_pred = y_test, val_predictions
print(classification_report(y_true, y_pred))


conf_mat = confusion_matrix(y_true, y_pred)
fig, ax = plt.subplots(figsize=(10,10))
sns.heatmap(conf_mat, annot=True, fmt='d',
            xticklabels=le.classes_, yticklabels=le.classes_)
plt.ylabel('Actual')
plt.xlabel('Predicted')
plt.show()






